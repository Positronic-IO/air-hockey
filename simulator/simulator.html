<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>AHR Web Simulator</title>

    <style>
        body{ background-color: ivory; }
        #canvas{border:1px solid red;}
    </style>
</head>
<body>
    <canvas id="canvas" width=480 height=640></canvas>

    <script>
        // get canvas related references
        var canvas = document.getElementById("canvas");
        var ctx = canvas.getContext("2d");
        var BB = canvas.getBoundingClientRect();
        var offsetX = BB.left;
        var offsetY = BB.top;
        var WIDTH = canvas.width;
        var HEIGHT = canvas.height;

        // drag related variables
        var dragok = false;
        var startX;
        var startY;

        // an array of objects that define different rectangles
        var puck = {
            x:WIDTH / 2,
            y:50,
            radius: 20,
            fill:"#444444",
            isDragging: false
        };

        var rects = [];
        rects.push({
            x: WIDTH/2,
            y: 50,
            width: 30,
            height: 30,
            fill: "#444444",
            isDragging: false
        });

        // listen for mouse events
        canvas.onmousedown = myDown;
        canvas.onmouseup = myUp;
        canvas.onmousemove = myMove;

        // call to draw the scene
        draw();

        // draw a single rect
        function rect(x, y, w, h) {
            ctx.beginPath();
            ctx.rect(x, y, w, h);
            ctx.closePath();
            ctx.fill();
        }

        function drawPuck(x,y,r) {
            ctx.beginPath();
            ctx.arc(x,y,r,0,Math.PI*2);
            ctx.closePath();
            ctx.fill();
        }

        // clear the canvas
        function clear() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
        }

        // redraw the scene
        function draw() {
            clear();
            ctx.fillStyle = "#FAF7F8";
            //rect(0, 0, WIDTH, HEIGHT);

            //puck(0,0,width,height);

            // redraw each rect in the rects[] array
            // for (var i = 0; i < rects.length; i++) {
            //     var r = rects[i];
            //     ctx.fillStyle = r.fill;
            //     rect(r.x, r.y, r.width, r.height);
            // }

            ctx.fillStyle = puck.fill;
            drawPuck(puck.x,puck.y,puck.radius);
        }


        // handle mousedown events
        function myDown(e) {

            // tell the browser we're handling this mouse event
            e.preventDefault();
            e.stopPropagation();

            // get the current mouse position
            var mx = parseInt(e.clientX - offsetX);
            var my = parseInt(e.clientY - offsetY);

            // test each rect to see if mouse is inside
            dragok = false;
            // for (var i = 0; i < rects.length; i++) {
            //     var r = rects[i];
            //     if (mx > r.x && mx < r.x + r.width && my > r.y && my < r.y + r.height) {
            //         // if yes, set that rects isDragging=true
            //         dragok = true;
            //         r.isDragging = true;
            //     }
            // }

            if (mx > puck.x - puck.radius && mx < puck.x + puck.radius && my > puck.y - puck.radius && my < puck.y + puck.radius) {
                // if yes, set that rects isDragging=true
                dragok = true;
                puck.isDragging = true;
            }

            // save the current mouse position
            startX = mx;
            startY = my;
        }


        // handle mouseup events
        function myUp(e) {  
            // tell the browser we're handling this mouse event
            e.preventDefault();
            e.stopPropagation();

            // clear all the dragging flags
            dragok = false;
            // for (var i = 0; i < rects.length; i++) {
            //     rects[i].isDragging = false;
            // }

            puck.isDragging = false;
        }


        // handle mouse moves
        function myMove(e) {
            // if we're dragging anything...
            if (dragok) {

                // tell the browser we're handling this mouse event
                e.preventDefault();
                e.stopPropagation();

                // get the current mouse position
                var mx = parseInt(e.clientX - offsetX);
                var my = parseInt(e.clientY - offsetY);

                // calculate the distance the mouse has moved
                // since the last mousemove
                var dx = mx - startX;
                var dy = my - startY;

                // move each rect that isDragging 
                // by the distance the mouse has moved
                // since the last mousemove
                // for (var i = 0; i < rects.length; i++) {
                //     var r = rects[i];
                //     if (r.isDragging) {
                //         r.x += dx;
                //         r.y += dy;
                //     }
                // }

                if (puck.isDragging) {
                    puck.x += dx;
                    puck.y += dy;
                }

                var puckPosition = {x:puck.x,y:puck.y};
                console.log('Puck Positon: ', puckPosition);

                // redraw the scene with the new rect positions
                draw();

                // reset the starting mouse position for the next mousemove
                startX = mx;
                startY = my;

            }
        }
    </script>
</body>
</html>